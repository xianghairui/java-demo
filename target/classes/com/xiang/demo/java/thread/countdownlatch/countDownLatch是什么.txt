CountDownLatch(http://www.importnew.com/15731.html)
	是在java1.5被引入的，跟它一起被引入的并发工具类还有CyclicBarrier、
	Semaphore、ConcurrentHashMap和BlockingQueue，它们都存在于
	java.util.concurrent包下。CountDownLatch这个类能够使一个线程
	等待其他线程完成各自的工作后再执行。
	例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务
	之后再执行。

CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个
	线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的
	线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。
	
在实时系统中的使用场景

让我们尝试罗列出在java实时系统中CountDownLatch都有哪些使用场景。我所罗列的都是我所能想到的。如果你有别的可能的使用方法，请在留言里列出来，这样会帮助到大家。

实现最大的并行性：
	有时我们想同时启动多个线程，实现最大程度的并行性。例如，我们想测试一个单例类。如果我们创建一个初始计数为1的CountDownLatch，并让所有线程都在这个锁上等待，那么我们可以很轻松地完成测试。我们只需调用 一次countDown()方法就可以让所有的等待线程同时恢复执行。
开始执行前等待n个线程完成各自任务：
	例如应用程序启动类要确保在处理用户请求前，所有N个外部系统已经启动和运行了。
死锁检测：
	一个非常方便的使用场景是，你可以使用n个线程访问共享资源，在每次测试阶段的线程数目是不同的，并尝试产生死锁。